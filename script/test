#!/usr/bin/env node

'use strict'

require('colors')
const argv = require('yargs')
  .option('core-main', {
    describe: 'Run core main process tests',
    boolean: true,
    default: false
  })
  .option('skip-main', {
    describe: 'Skip main process tests if they would otherwise run on your platform',
    boolean: true,
    default: false,
    conflicts: 'core-main'
  })
  .option('core-renderer', {
    describe: 'Run core renderer process tests',
    boolean: true,
    default: false
  })
  .option('core-benchmark', {
    describe: 'Run core benchmarks',
    boolean: true,
    default: false
  })
  .option('package', {
    describe: 'Run bundled package specs',
    boolean: true,
    default: false
  })
  .help()
  .argv

const assert = require('assert')
const async = require('async')
const childProcess = require('child_process')
const fs = require('fs-extra')
const glob = require('glob')
const path = require('path')
const temp = require('temp').track()

const CONFIG = require('./config')
const backupNodeModules = require('./lib/backup-node-modules')
const runApmInstall = require('./lib/run-apm-install')

const resourcePath = CONFIG.repositoryRootPath
let executablePath
if (process.platform === 'darwin') {
  const executablePaths = glob.sync(path.join(CONFIG.buildOutputPath, '*.app'))
  assert(executablePaths.length === 1, `A single application to run tests against was not found. ${executablePaths.join(',')}`)
  executablePath = path.join(executablePaths[0], 'Contents', 'MacOS', path.basename(executablePaths[0], '.app'))
} else if (process.platform === 'linux') {
  const executablePaths = glob.sync(path.join(CONFIG.buildOutputPath, 'atom-*', 'atom'))
  assert(executablePaths.length === 1, `A single application to run tests against was not found. ${executablePaths.join(',')}`)
  executablePath = executablePaths[0]
} else if (process.platform === 'win32') {
  const executablePaths = glob.sync(path.join(CONFIG.buildOutputPath, '**', 'atom*.exe'))
  assert(executablePaths.length === 1, `A single application to run tests against was not found. ${executablePaths.join(',')}`)
  executablePath = executablePaths[0]
} else {
  throw new Error('##[error] Running tests on this platform is not supported.')
}

function prepareEnv (suiteName) {
  const atomHomeDirPath = temp.mkdirSync(suiteName)
  const env = Object.assign({}, process.env, {ATOM_HOME: atomHomeDirPath})

  if (process.env.TEST_JUNIT_XML_ROOT) {
    // Tell Jasmine to output this suite's results as a JUnit XML file to a subdirectory of the root, so that a
    // CI system can interpret it.
    const fileName = suiteName + '.xml'
    const outputPath = path.join(process.env.TEST_JUNIT_XML_ROOT, fileName)
    env.TEST_JUNIT_XML_PATH = outputPath
  }

  return env
}

function runCoreMainProcessTests (callback) {
  const testPath = path.join(CONFIG.repositoryRootPath, 'spec', 'main-process')
  const testArguments = [
    '--resource-path', resourcePath,
    '--test', '--main-process', testPath
  ]

  if(process.env.CI && process.platform === 'linux') {
      testArguments.push('--no-sandbox')
  }

  const testEnv = Object.assign({}, prepareEnv('core-main-process'), {ATOM_GITHUB_INLINE_GIT_EXEC: 'true'})

  console.log('##[command] Executing core main process tests'.bold.green)
  const cp = childProcess.spawn(executablePath, testArguments, {stdio: 'inherit', env: testEnv})
  cp.on('error', error => { callback(error) })
  cp.on('close', exitCode => { callback(null, {exitCode, step: 'core-main-process', testCommand: `You can run the test again using: \n\t ${executablePath} ${testArguments.join(' ')}`}) })
}

// Build an array of functions, each running tests for a different rendering test
const coreRenderProcessTestSuites = []
const testPath = path.join(CONFIG.repositoryRootPath, 'spec')
let testFiles = glob.sync(path.join(testPath, '*-spec.+(js|coffee|ts|jsx|tsx|mjs)'))
for (let testFile of testFiles) {
  coreRenderProcessTestSuites.push( function (callback) {

    const testEnv = prepareEnv('core-render-process')
    console.log(`##[command] Executing core render process tests for ${testFile}`.bold.green)
    const testArguments = [
      '--resource-path', resourcePath,
      '--test', testFile
    ]
    const cp = childProcess.spawn(executablePath, testArguments, { env: testEnv})
    let stderrOutput = ''
    cp.stderr.on('data', data => { stderrOutput += data })
    cp.stdout.on('data', data => { stderrOutput += data })
    cp.on('error', error => {
      console.log(error, "error")
      callback(error)
    })
    cp.on('close', exitCode => {
      if (exitCode !== 0) {
        console.log(`##[error] Renderer tests failed for ${testFile}:`.red)
        console.log(stderrOutput)
      }
       callback(null, {exitCode, step: `core-render-process for ${testFile}.`, testCommand: `You can run the test again using: \n\t ${executablePath} ${testArguments.join(' ')}`})
     })
  })
}

// Build an array of functions, each running tests for a different bundled package
const packageTestSuites = []
for (let packageName in CONFIG.appMetadata.packageDependencies) {
  if (process.env.ATOM_PACKAGES_TO_TEST) {
    const packagesToTest = process.env.ATOM_PACKAGES_TO_TEST.split(',').map(pkg => pkg.trim())
    if (!packagesToTest.includes(packageName)) continue
  }

  const repositoryPackagePath = path.join(CONFIG.repositoryRootPath, 'node_modules', packageName)
  const testSubdir = ['spec', 'test'].find(subdir => fs.existsSync(path.join(repositoryPackagePath, subdir)))

  if (!testSubdir) {
    console.log(`No test folder found for package: ${packageName}`.yellow)
    continue
  }

  const testFolder = path.join(repositoryPackagePath, testSubdir)

  packageTestSuites.push(function (callback) {
    const testArguments = [
      '--resource-path', resourcePath,
      '--test', testFolder
    ]
    const testEnv = prepareEnv(`bundled-package-${packageName}`)

    const pkgJsonPath = path.join(repositoryPackagePath, 'package.json')
    const nodeModulesPath = path.join(repositoryPackagePath, 'node_modules')
    let finalize = () => null
    if (require(pkgJsonPath).atomTestRunner) {
      console.log(`##[command] Installing test runner dependencies for ${packageName}`.bold.green)
      if (fs.existsSync(nodeModulesPath)) {
        const backup = backupNodeModules(repositoryPackagePath)
        finalize = backup.restore
      } else {
        finalize = () => fs.removeSync(nodeModulesPath)
      }
      runApmInstall(repositoryPackagePath)
      console.log(`##[command] Executing ${packageName} tests`.green)
    } else {
      console.log(`##[command] Executing ${packageName} tests`.bold.green)
    }
    const cp = childProcess.spawn(executablePath, testArguments, {env: testEnv})

    let stderrOutput = ''
    cp.stderr.on('data', data => { stderrOutput += data })
    cp.stdout.on('data', data => { stderrOutput += data })
    cp.on('error', error => {
      console.log(error, "error")
      finalize()
      callback(error)
    })
    cp.on('close', exitCode => {
      if (exitCode !== 0) {
        console.log(`##[error] Package tests failed for ${packageName}:`.red)
        console.log(stderrOutput)
      }
      finalize()
      callback(null, {exitCode, step: `package-${packageName}.`, testCommand: `You can run the test again using: \n\t ${executablePath} ${testArguments.join(' ')}`})
    })
  })
}

function runBenchmarkTests (callback) {
  const benchmarksPath = path.join(CONFIG.repositoryRootPath, 'benchmarks')
  const testArguments = ['--benchmark-test', benchmarksPath]
  const testEnv = prepareEnv('benchmark')

  console.log('##[command] Executing benchmark tests'.bold.green)
  const cp = childProcess.spawn(executablePath, testArguments, {stdio: 'inherit', env: testEnv})
  cp.on('error', error => { callback(error) })
  cp.on('close', exitCode => { callback(null, {exitCode, step: 'core-benchmarks', testCommand: `You can run the test again using: \n\t ${executablePath} ${testArguments.join(' ')}`}) })
}

let testSuitesToRun = requestedTestSuites(process.platform)

function requestedTestSuites (platform) {
  // env variable or argv options
  let coreAll = process.env.ATOM_RUN_CORE_TESTS === 'true'
  let coreMain = process.env.ATOM_RUN_CORE_MAIN_TESTS === 'true' || argv.coreMain
  let coreRenderer = argv.coreRenderer || process.env.ATOM_RUN_CORE_RENDER_TESTS == 'true'
  let coreRenderer1 = process.env.ATOM_RUN_CORE_RENDER_TESTS === '1'
  let coreRenderer2 = process.env.ATOM_RUN_CORE_RENDER_TESTS === '2'
  let packageAll = argv.package || process.env.ATOM_RUN_PACKAGE_TESTS == 'true'
  let packages1 = process.env.ATOM_RUN_PACKAGE_TESTS === '1'
  let packages2 = process.env.ATOM_RUN_PACKAGE_TESTS === '2'
  let benchmark = argv.coreBenchmark

  // Operating system overrides:
  coreMain = coreMain || (platform === 'linux') || (platform === 'win32' && process.arch === 'x86')

  // split package tests (used for macos in CI)
  const PACKAGES_TO_TEST_IN_PARALLEL = 23
  // split core render test (used for windows x64 in CI)
  const CORE_RENDER_TO_TEST_IN_PARALLEL = 45

  let suites = []
  // Core tess
  if (coreAll) {
    suites.push(...[runCoreMainProcessTests, ...coreRenderProcessTestSuites])
  } else {

    // Core main tests
    if (coreMain) {
      suites.push(runCoreMainProcessTests)
    }

    // Core renderer tests
    if (coreRenderer) {
      suites.push(...coreRenderProcessTestSuites)
    } else {
      // split
      if (coreRenderer1) {
        suites.push(...coreRenderProcessTestSuites.slice(0, CORE_RENDER_TO_TEST_IN_PARALLEL))
      }
      if (coreRenderer2) {
        suites.push(...coreRenderProcessTestSuites.slice(CORE_RENDER_TO_TEST_IN_PARALLEL))
      }
    }

  }

  // Package tests
  if (packageAll) {
    suites.push(...packageTestSuites)
  } else {
    // split
    if (packages1) {
      suites.push(...packageTestSuites.slice(0, PACKAGES_TO_TEST_IN_PARALLEL))
    }
    if (packages2) {
      suites.push(...packageTestSuites.slice(PACKAGES_TO_TEST_IN_PARALLEL))
    }
  }

  // Benchmark tests
  if (benchmark) {
    suites.push(runBenchmarkTests)
  }

  if (argv.skipMainProcessTests) {
    suites = suites.filter(suite => suite !== runCoreMainProcessTests)
  }

  // Remove duplicates
  suites = Array.from(new Set(suites))

  if (suites.length == 0) {
    throw new Error("No tests was requested")
  }

  return suites
}

async.series(testSuitesToRun, function (err, results) {
  if (err) {
    console.error(err)
    process.exit(1)
  } else {
    const failedSteps = results.filter(({exitCode}) => exitCode !== 0)

    if (failedSteps.length > 0) {
      console.warn("##[error] \n \n *** Reporting the errors that happened in all of the tests: *** \n \n")
      for (const {step, testCommand} of failedSteps) {
        console.error(`##[error] The '${step}' test step finished with a non-zero exit code \n ${testCommand}`)
      }
      process.exit(1)
    }

    process.exit(0)
  }
})
