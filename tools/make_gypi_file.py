# Copyright (c) 2011 The Chromium Embedded Framework Authors. All rights
# reserved. Use of this source code is governed by a BSD-style license that
# can be found in the LICENSE file.

from cef_parser import *

def make_gypi_file(header):
    # header string
    result = \
"""# Copyright (c) $YEAR$ The Chromium Embedded Framework Authors. All rights
# reserved. Use of this source code is governed by a BSD-style license that
# can be found in the LICENSE file.
#
# ---------------------------------------------------------------------------
#
# This file was generated by the CEF translator tool and should not edited
# by hand. See the translator.README.txt file in the tools directory for
# more information.
#

{
  'variables': {
"""
    
    filenames = sorted(header.get_file_names())
    
    # cpp includes
    result += "    'autogen_cpp_includes': [\n"
    for filename in filenames:
        result += "      'include/"+filename+"',\n"
    result += "    ],\n"
    
    # capi includes
    result += "    'autogen_capi_includes': [\n"
    for filename in filenames:
        result += "      'include/capi/"+get_capi_file_name(filename)+"',\n"
    result += "    ],\n"
    
    classes = sorted(header.get_class_names())
    
    # library side includes
    result += "    'autogen_library_side': [\n"
    for clsname in classes:
        cls = header.get_class(clsname)
        filename = get_capi_name(clsname[3:], False)
        if cls.is_library_side():
            result += "      'libcef_dll/cpptoc/"+filename+"_cpptoc.cc',\n" \
                      "      'libcef_dll/cpptoc/"+filename+"_cpptoc.h',\n"
        else:
            result += "      'libcef_dll/ctocpp/"+filename+"_ctocpp.cc',\n" \
                      "      'libcef_dll/ctocpp/"+filename+"_ctocpp.h',\n"  
    result += "    ],\n"    
    
    # client side includes
    result += "    'autogen_client_side': [\n"
    for clsname in classes:
        cls = header.get_class(clsname)
        filename = get_capi_name(clsname[3:], False)
        if cls.is_library_side():
            result += "      'libcef_dll/ctocpp/"+filename+"_ctocpp.cc',\n" \
                      "      'libcef_dll/ctocpp/"+filename+"_ctocpp.h',\n"  
        else:
            result += "      'libcef_dll/cpptoc/"+filename+"_cpptoc.cc',\n" \
                      "      'libcef_dll/cpptoc/"+filename+"_cpptoc.h',\n"
    result += "    ],\n"    
    
    # footer string
    result += \
"""  },
}
"""
    
    # add the copyright year
    result = result.replace('$YEAR$', get_year())

    return result

def write_gypi_file(header, file, backup):
    if path_exists(file):
        oldcontents = read_file(file)
    else:
        oldcontents = ''
    
    newcontents = make_gypi_file(header)
    if newcontents != oldcontents:
        if backup and oldcontents != '':
            backup_file(file)
        write_file(file, newcontents)
        return True
    
    return False


# test the module
if __name__ == "__main__":
    import sys
    
    # verify that the correct number of command-line arguments are provided
    if len(sys.argv) < 2:
        sys.stderr.write('Usage: '+sys.argv[0]+' <infile>')
        sys.exit()
        
    # create the header object
    header = obj_header()
    header.add_file(sys.argv[1])
    
    # dump the result to stdout
    sys.stdout.write(make_gypi_file(header))
